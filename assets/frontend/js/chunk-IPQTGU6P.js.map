{
  "version": 3,
  "sources": ["../node_modules/redux/es/redux.js", "../node_modules/symbol-observable/es/ponyfill.js", "../node_modules/symbol-observable/es/index.js", "../node_modules/@rematch/core/src/reduxStore.ts", "../node_modules/@rematch/core/src/validate.ts", "../node_modules/@rematch/core/src/dispatcher.ts", "../node_modules/@rematch/core/src/bag.ts", "../node_modules/@rematch/core/src/rematchStore.ts", "../node_modules/@rematch/core/src/config.ts", "../node_modules/@rematch/core/src/index.ts"],
  "sourcesContent": ["import $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nvar randomString = function randomString() {\n  return Math.random().toString(36).substring(7).split('').join('.');\n};\n\nvar ActionTypes = {\n  INIT: \"@@redux/INIT\" + randomString(),\n  REPLACE: \"@@redux/REPLACE\" + randomString(),\n  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {\n    return \"@@redux/PROBE_UNKNOWN_ACTION\" + randomString();\n  }\n};\n\n/**\n * @param {any} obj The object to inspect.\n * @returns {boolean} True if the argument appears to be a plain object.\n */\nfunction isPlainObject(obj) {\n  if (typeof obj !== 'object' || obj === null) return false;\n  var proto = obj;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(obj) === proto;\n}\n\n/**\n * Creates a Redux store that holds the state tree.\n * The only way to change the data in the store is to call `dispatch()` on it.\n *\n * There should only be a single store in your app. To specify how different\n * parts of the state tree respond to actions, you may combine several reducers\n * into a single reducer function by using `combineReducers`.\n *\n * @param {Function} reducer A function that returns the next state tree, given\n * the current state tree and the action to handle.\n *\n * @param {any} [preloadedState] The initial state. You may optionally specify it\n * to hydrate the state from the server in universal apps, or to restore a\n * previously serialized user session.\n * If you use `combineReducers` to produce the root reducer function, this must be\n * an object with the same shape as `combineReducers` keys.\n *\n * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n * to enhance the store with third-party capabilities such as middleware,\n * time travel, persistence, etc. The only store enhancer that ships with Redux\n * is `applyMiddleware()`.\n *\n * @returns {Store} A Redux store that lets you read the state, dispatch actions\n * and subscribe to changes.\n */\n\nfunction createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {\n    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');\n  }\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n  /**\n   * This makes a shallow copy of currentListeners so we can use\n   * nextListeners as a temporary list while dispatching.\n   *\n   * This prevents any bugs around consumers calling\n   * subscribe/unsubscribe in the middle of a dispatch.\n   */\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n\n\n  function getState() {\n    if (isDispatching) {\n      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');\n    }\n\n    return currentState;\n  }\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n\n\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.');\n    }\n\n    if (isDispatching) {\n      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\n    }\n\n    var isSubscribed = true;\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      if (isDispatching) {\n        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');\n      }\n\n      isSubscribed = false;\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n      currentListeners = null;\n    };\n  }\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing \u201Cwhat changed\u201D. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n\n\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n\n\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.\n    // Any reducers that existed in both the new and old rootReducer\n    // will receive the previous state. This effectively populates\n    // the new state tree with any relevant data from the old one.\n\n    dispatch({\n      type: ActionTypes.REPLACE\n    });\n  }\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n\n\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object' || observer === null) {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  } // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n\n\n  dispatch({\n    type: ActionTypes.INIT\n  });\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nfunction warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n\n\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n  } catch (e) {} // eslint-disable-line no-empty\n\n}\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionDescription = actionType && \"action \\\"\" + String(actionType) + \"\\\"\" || 'an action';\n  return \"Given \" + actionDescription + \", reducer \\\"\" + key + \"\\\" returned undefined. \" + \"To ignore an action, you must explicitly return the previous state. \" + \"If you want this reducer to hold no value, you can return null instead of undefined.\";\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return \"The \" + argumentName + \" has unexpected type of \\\"\" + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + \"\\\". Expected argument to be an object with the following \" + (\"keys: \\\"\" + reducerKeys.join('\", \"') + \"\\\"\");\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n  if (action && action.type === ActionTypes.REPLACE) return;\n\n  if (unexpectedKeys.length > 0) {\n    return \"Unexpected \" + (unexpectedKeys.length > 1 ? 'keys' : 'key') + \" \" + (\"\\\"\" + unexpectedKeys.join('\", \"') + \"\\\" found in \" + argumentName + \". \") + \"Expected to find one of the known reducer keys instead: \" + (\"\\\"\" + reducerKeys.join('\", \"') + \"\\\". Unexpected keys will be ignored.\");\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, {\n      type: ActionTypes.INIT\n    });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined during initialization. \" + \"If the state passed to the reducer is undefined, you must \" + \"explicitly return the initial state. The initial state may \" + \"not be undefined. If you don't want to set a value for this reducer, \" + \"you can use null instead of undefined.\");\n    }\n\n    if (typeof reducer(undefined, {\n      type: ActionTypes.PROBE_UNKNOWN_ACTION()\n    }) === 'undefined') {\n      throw new Error(\"Reducer \\\"\" + key + \"\\\" returned undefined when probed with a random type. \" + (\"Don't try to handle \" + ActionTypes.INIT + \" or other actions in \\\"redux/*\\\" \") + \"namespace. They are considered private. Instead, you must return the \" + \"current state for any unknown actions, unless it is undefined, \" + \"in which case you must return the initial state, regardless of the \" + \"action type. The initial state may not be undefined, but can be null.\");\n    }\n  });\n}\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\n\n\nfunction combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(\"No reducer provided for key \\\"\" + key + \"\\\"\");\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same\n  // keys multiple times.\n\n  var unexpectedKeyCache;\n\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError;\n\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination(state, action) {\n    if (state === void 0) {\n      state = {};\n    }\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n\n    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;\n    return hasChanged ? nextState : state;\n  };\n}\n\nfunction bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(this, arguments));\n  };\n}\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass an action creator as the first argument,\n * and get a dispatch wrapped function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\n\n\nfunction bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(\"bindActionCreators expected an object or a function, instead received \" + (actionCreators === null ? 'null' : typeof actionCreators) + \". \" + \"Did you write \\\"import ActionCreators from\\\" instead of \\\"import * as ActionCreators from\\\"?\");\n  }\n\n  var boundActionCreators = {};\n\n  for (var key in actionCreators) {\n    var actionCreator = actionCreators[key];\n\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n\n  return boundActionCreators;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    keys.push.apply(keys, Object.getOwnPropertySymbols(object));\n  }\n\n  if (enumerableOnly) keys = keys.filter(function (sym) {\n    return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n  });\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\n/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\n\nfunction applyMiddleware() {\n  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function () {\n      var store = createStore.apply(void 0, arguments);\n\n      var _dispatch = function dispatch() {\n        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');\n      };\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch() {\n          return _dispatch.apply(void 0, arguments);\n        }\n      };\n      var chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(void 0, chain)(store.dispatch);\n      return _objectSpread2({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n/*\n * This is a dummy function to check if the function name has been altered by minification.\n * If the function has been minified and NODE_ENV !== 'production', warn the user.\n */\n\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \"production\". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { ActionTypes as __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore };\n", "export default function symbolObservablePonyfill(root) {\n\tvar result;\n\tvar Symbol = root.Symbol;\n\n\tif (typeof Symbol === 'function') {\n\t\tif (Symbol.observable) {\n\t\t\tresult = Symbol.observable;\n\t\t} else {\n\t\t\tresult = Symbol('observable');\n\t\t\tSymbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n", "/* global window */\nimport ponyfill from './ponyfill.js';\n\nvar root;\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = ponyfill(root);\nexport default result;\n", "import * as Redux from 'redux'\nimport {\n\tAction,\n\tConfigRedux,\n\tModelReducers,\n\tNamedModel,\n\tRematchBag,\n\tDevtoolOptions,\n\tModels,\n\tRematchRootState,\n} from './types'\n\n/**\n * Creates 'combined' reducer for each model and then merges those reducers\n * together into a 'root' reducer. It then creates a Redux store with\n * middlewares and enhancers.\n */\nexport default function createReduxStore<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>,\n\tRootState = RematchRootState<TModels, TExtraModels>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Store<RootState> {\n\tbag.models.forEach((model) => createModelReducer(bag, model))\n\n\tconst rootReducer = createRootReducer<RootState, TModels, TExtraModels>(bag)\n\n\tconst middlewares = Redux.applyMiddleware(...bag.reduxConfig.middlewares)\n\tconst enhancers = composeEnhancersWithDevtools(\n\t\tbag.reduxConfig.devtoolOptions\n\t)(...bag.reduxConfig.enhancers, middlewares)\n\n\tconst createStore = bag.reduxConfig.createStore || Redux.createStore\n\tconst bagInitialState = bag.reduxConfig.initialState\n\tconst initialState = bagInitialState === undefined ? {} : bagInitialState\n\n\treturn createStore<RootState, Action, any, typeof initialState>(\n\t\trootReducer,\n\t\tinitialState,\n\t\tenhancers\n\t)\n}\n\n/**\n * Creates a combined reducer for a given model. What it means is that:\n * - it forms an action name for each model's reducer as 'modelName/reducerKey'\n * - it creates a mapping from action name to its reducer\n * - it wraps the mapping with a function (combined reducer) that selects and\n *   runs a reducer based on the incoming action\n * - if the model also has a base reducer defined, it creates a function which\n *   first runs the incoming action through this reducer and then passes the\n *   resulting state and the same action to combined reducer\n *\n * The final result - a function, is returned.\n */\nexport function createModelReducer<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>,\n\tTState extends NamedModel<TModels>['state'] = any\n>(bag: RematchBag<TModels, TExtraModels>, model: NamedModel<TModels>): void {\n\tconst modelReducers: ModelReducers<TState> = {}\n\n\t// build action name for each reducer and create mapping from name to reducer\n\tconst modelReducerKeys = Object.keys(model.reducers)\n\tmodelReducerKeys.forEach((reducerKey) => {\n\t\tconst actionName = isAlreadyActionName(reducerKey)\n\t\t\t? reducerKey\n\t\t\t: `${model.name}/${reducerKey}`\n\n\t\tmodelReducers[actionName] = model.reducers[reducerKey]\n\t})\n\n\t// select and run a reducer based on the incoming action\n\tconst combinedReducer = (\n\t\tstate: TState = model.state,\n\t\taction: Action\n\t): TState => {\n\t\tif (action.type in modelReducers) {\n\t\t\treturn modelReducers[action.type](state, action.payload, action.meta)\n\t\t}\n\n\t\treturn state\n\t}\n\n\tconst modelBaseReducer = model.baseReducer\n\n\t// when baseReducer is defined, run the action first through it\n\tlet reducer = !modelBaseReducer\n\t\t? combinedReducer\n\t\t: (state: TState = model.state, action: Action): TState =>\n\t\t\t\tcombinedReducer(modelBaseReducer(state, action), action)\n\n\tbag.forEachPlugin('onReducer', (onReducer) => {\n\t\treducer = onReducer(reducer, model.name, bag) || reducer\n\t})\n\n\tbag.reduxConfig.reducers[model.name] = reducer\n}\n\n/**\n * It merges all reducers in config using mergeReducers function. Additionally,\n * if user supplied any rootReducers, a wrapper function around merged reducers\n * is created. It first feeds each into its corresponding 'root' reducer (if\n * it's available), and then passes on the resulting state to the merged reducer.\n */\nexport function createRootReducer<\n\tTRootState,\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(bag: RematchBag<TModels, TExtraModels>): Redux.Reducer<TRootState, Action> {\n\tconst { rootReducers } = bag.reduxConfig\n\tconst mergedReducers = mergeReducers<TRootState>(bag.reduxConfig)\n\tlet rootReducer = mergedReducers\n\n\tif (rootReducers && Object.keys(rootReducers).length) {\n\t\trootReducer = (\n\t\t\tstate: TRootState | undefined,\n\t\t\taction: Action\n\t\t): TRootState => {\n\t\t\tconst actionRootReducer = rootReducers[action.type]\n\n\t\t\tif (actionRootReducer) {\n\t\t\t\treturn mergedReducers(actionRootReducer(state, action), action)\n\t\t\t}\n\n\t\t\treturn mergedReducers(state, action)\n\t\t}\n\t}\n\n\tbag.forEachPlugin('onRootReducer', (onRootReducer) => {\n\t\trootReducer = onRootReducer(rootReducer, bag) || rootReducer\n\t})\n\n\treturn rootReducer\n}\n\n/**\n * Merges all reducers defined in config into one function using user supplied\n * or default combineReducers function.\n * If there are no reducers defined, it returns a function that just returns\n * the state for all incoming actions.\n */\nfunction mergeReducers<TRootState>(\n\treduxConfig: ConfigRedux<TRootState>\n): Redux.Reducer<TRootState, Action> {\n\tconst combineReducers = reduxConfig.combineReducers || Redux.combineReducers\n\n\tif (!Object.keys(reduxConfig.reducers).length) {\n\t\treturn (state: any): TRootState => state\n\t}\n\n\treturn combineReducers(reduxConfig.reducers as Redux.ReducersMapObject)\n}\n\n/**\n * Returns Redux Devtools compose method unless it's disabled, in which case it\n * returns default Redux.compose.\n */\nfunction composeEnhancersWithDevtools(\n\tdevtoolOptions: DevtoolOptions = {}\n): (...args: any[]) => Redux.StoreEnhancer {\n\treturn !devtoolOptions.disabled &&\n\t\ttypeof window === 'object' &&\n\t\twindow.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n\t\t? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(devtoolOptions)\n\t\t: Redux.compose\n}\n\n/**\n * Determines if a reducer key is already an action name, for example -\n * a listener on another model.\n */\nfunction isAlreadyActionName(reducerKey: string): boolean {\n\treturn reducerKey.indexOf('/') > -1\n}\n", "import {\n\tConfig,\n\tModelEffects,\n\tModelReducers,\n\tNamedModel,\n\tPlugin,\n\tModels,\n} from './types'\n\n/**\n * If the first item is true, it means there is an error described by\n * the second item.\n */\nexport type Validation = [boolean | undefined, string]\n\n/**\n * Checks if a parameter is a valid object.\n */\nexport const isObject = <T>(obj: T): boolean =>\n\ttypeof obj === 'object' && obj !== null && !Array.isArray(obj)\n\n/**\n * Checks if a parameter is a valid function but only when it's defined.\n * Otherwise, always returns true.\n */\nexport const ifDefinedIsFunction = <T>(func: T): boolean =>\n\t!func || typeof func === 'function'\n\n/**\n * Takes an array of arrays of validations. Collects all errors and throws.\n * Should be used by plugins to keep the validation behaviour the same for all\n * Rematch-related libraries.\n */\nconst validate = (runValidations: () => Validation[]): void => {\n\tif (process.env.NODE_ENV !== 'production') {\n\t\tconst validations = runValidations()\n\t\tconst errors: string[] = []\n\n\t\tvalidations.forEach((validation) => {\n\t\t\tconst isInvalid = validation[0]\n\t\t\tconst errorMessage = validation[1]\n\t\t\tif (isInvalid) {\n\t\t\t\terrors.push(errorMessage)\n\t\t\t}\n\t\t})\n\n\t\tif (errors.length > 0) {\n\t\t\tthrow new Error(errors.join(', '))\n\t\t}\n\t}\n}\n\nexport const validateConfig = <\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(\n\tconfig: Config<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[!Array.isArray(config.plugins), 'init config.plugins must be an array'],\n\t\t[!isObject(config.models), 'init config.models must be an object'],\n\t\t[\n\t\t\t!isObject(config.redux.reducers),\n\t\t\t'init config.redux.reducers must be an object',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.middlewares),\n\t\t\t'init config.redux.middlewares must be an array',\n\t\t],\n\t\t[\n\t\t\t!Array.isArray(config.redux.enhancers),\n\t\t\t'init config.redux.enhancers must be an array of functions',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.combineReducers),\n\t\t\t'init config.redux.combineReducers must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(config.redux.createStore),\n\t\t\t'init config.redux.createStore must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModel = <\n\tTModels extends Models<TModels> = Record<string, any>\n>(\n\tmodel: NamedModel<TModels>\n): void => {\n\tvalidate(() => [\n\t\t[!model, 'model config is required'],\n\t\t[typeof model.name !== 'string', 'model \"name\" [string] is required'],\n\t\t[\n\t\t\tmodel.state === undefined && model.baseReducer === undefined,\n\t\t\t'model \"state\" is required',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(model.baseReducer),\n\t\t\t'model \"baseReducer\" must be a function',\n\t\t],\n\t])\n}\n\nexport const validatePlugin = <\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(\n\tplugin: Plugin<TModels, TExtraModels>\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onStoreCreated),\n\t\t\t'Plugin onStoreCreated must be a function',\n\t\t],\n\t\t[!ifDefinedIsFunction(plugin.onModel), 'Plugin onModel must be a function'],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onReducer),\n\t\t\t'Plugin onReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.onRootReducer),\n\t\t\t'Plugin onRootReducer must be a function',\n\t\t],\n\t\t[\n\t\t\t!ifDefinedIsFunction(plugin.createMiddleware),\n\t\t\t'Plugin createMiddleware must be a function',\n\t\t],\n\t])\n}\n\nexport const validateModelReducer = (\n\tmodelName: string,\n\treducers: ModelReducers,\n\treducerName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!reducerName.match(/\\/.+\\//),\n\t\t\t`Invalid reducer name (${modelName}/${reducerName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof reducers[reducerName] !== 'function',\n\t\t\t`Invalid reducer (${modelName}/${reducerName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport const validateModelEffect = <TModels extends Models<TModels>>(\n\tmodelName: string,\n\teffects: ModelEffects<TModels>,\n\teffectName: string\n): void => {\n\tvalidate(() => [\n\t\t[\n\t\t\t!!effectName.match(/\\//),\n\t\t\t`Invalid effect name (${modelName}/${effectName})`,\n\t\t],\n\t\t[\n\t\t\ttypeof effects[effectName] !== 'function',\n\t\t\t`Invalid effect (${modelName}/${effectName}). Must be a function`,\n\t\t],\n\t])\n}\n\nexport default validate\n", "import {\n\tAction,\n\tModelEffects,\n\tModelEffectsCreator,\n\tModels,\n\tNamedModel,\n\tRematchBag,\n\tRematchDispatcher,\n\tEffectRematchDispatcher,\n\tRematchStore,\n} from './types'\nimport { validateModelEffect, validateModelReducer } from './validate'\n\n/**\n * Builds a dispatcher for given model name and action name. The dispatched\n * action will have a type `modelName/actionName`.\n * Additionally, adds the isEffect property to the created dispatcher.\n * isEffect helps to differentiate effects dispatchers from reducer dispatchers.\n */\nconst createActionDispatcher = <\n\tTModels extends Models<TModels> = Record<string, any>\n>(\n\trematch: RematchStore<TModels>,\n\tmodelName: string,\n\tactionName: string,\n\tisEffect: boolean\n): RematchDispatcher | EffectRematchDispatcher => {\n\treturn Object.assign(\n\t\t(payload?: any, meta?: any): Action => {\n\t\t\tconst action: Action = { type: `${modelName}/${actionName}` }\n\n\t\t\tif (typeof payload !== 'undefined') {\n\t\t\t\taction.payload = payload\n\t\t\t}\n\n\t\t\tif (typeof meta !== 'undefined') {\n\t\t\t\taction.meta = meta\n\t\t\t}\n\n\t\t\treturn rematch.dispatch(action)\n\t\t},\n\t\t{\n\t\t\tisEffect,\n\t\t}\n\t)\n}\n\n/**\n * Creates a dispatcher object for a model - it contains a mapping from all\n * reducers and effects *names* to functions which dispatch their corresponding\n * actions.\n */\nconst createDispatcher = <\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTModel extends NamedModel<TModels> = NamedModel\n>(\n\trematch: RematchStore<TModels>,\n\tbag: RematchBag<TModels>,\n\tmodel: TModel\n): void => {\n\tconst modelDispatcher = rematch.dispatch[model.name]\n\n\t// map reducer names to dispatch actions\n\tconst modelReducersKeys = Object.keys(model.reducers)\n\tmodelReducersKeys.forEach((reducerName) => {\n\t\tvalidateModelReducer(model.name, model.reducers, reducerName)\n\n\t\tmodelDispatcher[reducerName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\treducerName,\n\t\t\tfalse\n\t\t)\n\t})\n\n\tlet effects: ModelEffects<TModels> = {}\n\n\t// 'effects' might be actually a function creating effects\n\tif (model.effects) {\n\t\teffects =\n\t\t\ttypeof model.effects === 'function'\n\t\t\t\t? (model.effects as ModelEffectsCreator<TModels>)(rematch.dispatch)\n\t\t\t\t: model.effects\n\t}\n\n\t// map effects names to dispatch actions\n\tconst effectKeys = Object.keys(effects)\n\teffectKeys.forEach((effectName) => {\n\t\tvalidateModelEffect(model.name, effects, effectName)\n\n\t\tbag.effects[`${model.name}/${effectName}`] = effects[effectName].bind(\n\t\t\tmodelDispatcher\n\t\t)\n\n\t\tmodelDispatcher[effectName] = createActionDispatcher(\n\t\t\trematch,\n\t\t\tmodel.name,\n\t\t\teffectName,\n\t\t\ttrue\n\t\t)\n\t})\n}\n\nexport default createDispatcher\n", "import { Config, Model, Models, NamedModel, RematchBag } from './types'\nimport { validateModel } from './validate'\n\n/**\n * Creates and returns a 'Rematch Bag', which is a set of configuration options\n * used by the Rematch library in various functions.\n */\nexport default function createRematchBag<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(config: Config<TModels, TExtraModels>): RematchBag<TModels, TExtraModels> {\n\treturn {\n\t\tmodels: createNamedModels(config.models),\n\t\treduxConfig: config.redux,\n\t\tforEachPlugin(method, fn): void {\n\t\t\tconfig.plugins.forEach((plugin) => {\n\t\t\t\tif (plugin[method]) {\n\t\t\t\t\tfn(plugin[method]!)\n\t\t\t\t}\n\t\t\t})\n\t\t},\n\t\teffects: {},\n\t}\n}\n\n/**\n * Transforms mapping from a model name to a model object, into an array of\n * 'named' models - models with embedded name and default value for reducers\n * if user didn't provide any.\n */\nfunction createNamedModels<\n\tTModels extends Models<TModels> = Record<string, any>\n>(models: TModels): NamedModel<TModels>[] {\n\treturn Object.keys(models).map((modelName: string) => {\n\t\tconst model = createNamedModel(modelName, models[modelName])\n\t\tvalidateModel(model)\n\t\treturn model\n\t})\n}\n\n/**\n * Transforms a model into 'named' model - model which contains 'name' and\n * 'reducers' properties if user didn't provide any.\n */\nfunction createNamedModel<\n\tTModels extends Models<TModels> = Record<string, any>\n>(name: string, model: Model<TModels>): NamedModel<TModels> {\n\treturn {\n\t\tname,\n\t\treducers: {},\n\t\t...model,\n\t}\n}\n", "import { Middleware } from 'redux'\nimport {\n\tAction,\n\tConfig,\n\tExposedFunction,\n\tModels,\n\tNamedModel,\n\tObjectNotAFunction,\n\tPlugin,\n\tRematchBag,\n\tRematchStore,\n\tModelDispatcher,\n\tRematchDispatch,\n} from './types'\nimport createReduxStore, {\n\tcreateModelReducer,\n\tcreateRootReducer,\n} from './reduxStore'\nimport createDispatcher from './dispatcher'\nimport { validateModel } from './validate'\nimport createRematchBag from './bag'\n\nexport default function createRematchStore<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(config: Config<TModels, TExtraModels>): RematchStore<TModels, TExtraModels> {\n\t// setup rematch 'bag' for storing useful values and functions\n\tconst bag = createRematchBag(config)\n\n\t// add middleware for handling effects\n\tbag.reduxConfig.middlewares.push(createEffectsMiddleware(bag))\n\n\t// collect middlewares from plugins\n\tbag.forEachPlugin('createMiddleware', (createMiddleware) => {\n\t\tbag.reduxConfig.middlewares.push(createMiddleware(bag))\n\t})\n\n\tconst reduxStore = createReduxStore(bag)\n\n\tlet rematchStore = {\n\t\t...reduxStore,\n\t\tname: config.name,\n\t\taddModel(model: NamedModel<TModels>) {\n\t\t\tvalidateModel(model)\n\t\t\tcreateModelReducer(bag, model)\n\t\t\tprepareModel(this, bag, model)\n\t\t\tthis.replaceReducer(createRootReducer(bag))\n\t\t\treduxStore.dispatch({ type: '@@redux/REPLACE' })\n\t\t},\n\t} as RematchStore<TModels, TExtraModels>\n\n\taddExposed(rematchStore, config.plugins)\n\n\trematchStore.addModel.bind(rematchStore)\n\n\t// generate dispatch[modelName][actionName] for all reducers and effects\n\tbag.models.forEach((model) => prepareModel(rematchStore, bag, model))\n\n\tbag.forEachPlugin('onStoreCreated', (onStoreCreated) => {\n\t\trematchStore = onStoreCreated(rematchStore, bag) || rematchStore\n\t})\n\n\treturn rematchStore\n}\n\nfunction createEffectsMiddleware<\n\tTModels extends Models<TModels> = Record<string, any>\n>(bag: RematchBag<TModels>): Middleware {\n\treturn (store) => (next) => (action: Action): any => {\n\t\tif (action.type in bag.effects) {\n\t\t\t// first run reducer action if exists\n\t\t\tnext(action)\n\n\t\t\t// then run the effect and return its result\n\t\t\treturn bag.effects[action.type](\n\t\t\t\taction.payload,\n\t\t\t\tstore.getState(),\n\t\t\t\taction.meta\n\t\t\t)\n\t\t}\n\n\t\treturn next(action)\n\t}\n}\n\nfunction prepareModel<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTModel extends NamedModel<TModels> = NamedModel\n>(\n\trematchStore: RematchStore<TModels>,\n\tbag: RematchBag<TModels>,\n\tmodel: TModel\n): void {\n\tconst modelDispatcher = {} as ModelDispatcher<TModel, TModels>\n\n\t// inject model so effects creator can access it\n\trematchStore.dispatch[\n\t\t`${model.name}` as keyof RematchDispatch<TModels>\n\t] = modelDispatcher\n\n\tcreateDispatcher(rematchStore, bag, model)\n\n\tbag.forEachPlugin('onModel', (onModel) => {\n\t\tonModel(model, rematchStore)\n\t})\n}\n\n/**\n * Adds properties exposed by plugins into the Rematch instance. If a exposed\n * property is a function, it passes rematch as the first argument.\n *\n * If you're implementing a plugin in TypeScript, extend Rematch namespace by\n * adding the properties that you exposed from your plugin.\n */\nfunction addExposed<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(\n\tstore: RematchStore<TModels, TExtraModels>,\n\tplugins: Plugin<TModels, TExtraModels>[]\n): void {\n\tplugins.forEach((plugin) => {\n\t\tif (!plugin.exposed) return\n\t\tconst pluginKeys = Object.keys(plugin.exposed)\n\t\tpluginKeys.forEach((key) => {\n\t\t\tif (!plugin.exposed) return\n\t\t\tconst exposedItem = plugin.exposed[key] as\n\t\t\t\t| ExposedFunction\n\t\t\t\t| ObjectNotAFunction\n\t\t\tconst isExposedFunction = typeof exposedItem === 'function'\n\n\t\t\tstore[key] = isExposedFunction\n\t\t\t\t? (...params: any[]): any =>\n\t\t\t\t\t\t(exposedItem as ExposedFunction)(store, ...params)\n\t\t\t\t: Object.create(plugin.exposed[key])\n\t\t})\n\t})\n}\n", "import { InitConfig, Config, Models } from './types'\nimport { validateConfig, validatePlugin } from './validate'\n\nlet count = 0\n\n/**\n * Builds complete Rematch config using default values for properties not\n * supplied by the user. Additionally, applies changes to the config made by\n * the plugins selected by the user.\n */\nexport default function createConfig<\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(\n\tinitConfig: InitConfig<TModels, TExtraModels>\n): Config<TModels, TExtraModels> {\n\tconst storeName = initConfig.name ?? `Rematch Store ${count}`\n\n\tcount += 1\n\n\tconst config = {\n\t\tname: storeName,\n\t\tmodels: initConfig.models || {},\n\t\tplugins: initConfig.plugins || [],\n\t\tredux: {\n\t\t\treducers: {},\n\t\t\trootReducers: {},\n\t\t\tenhancers: [],\n\t\t\tmiddlewares: [],\n\t\t\t...initConfig.redux,\n\t\t\tdevtoolOptions: {\n\t\t\t\tname: storeName,\n\t\t\t\t...(initConfig.redux?.devtoolOptions ?? {}),\n\t\t\t},\n\t\t},\n\t} as Config\n\n\tvalidateConfig(config)\n\n\t// Apply changes to the config required by plugins\n\tconfig.plugins.forEach((plugin) => {\n\t\tif (plugin.config) {\n\t\t\t// Collect new models\n\t\t\tconfig.models = merge(config.models, plugin.config.models)\n\n\t\t\t// Collect redux configuration changes\n\t\t\tif (plugin.config.redux) {\n\t\t\t\tconfig.redux.initialState = merge(\n\t\t\t\t\tconfig.redux.initialState,\n\t\t\t\t\tplugin.config.redux.initialState\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.reducers = merge(\n\t\t\t\t\tconfig.redux.reducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.rootReducers = merge(\n\t\t\t\t\tconfig.redux.rootReducers,\n\t\t\t\t\tplugin.config.redux.reducers\n\t\t\t\t)\n\n\t\t\t\tconfig.redux.enhancers = [\n\t\t\t\t\t...config.redux.enhancers,\n\t\t\t\t\t...(plugin.config.redux.enhancers || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.middlewares = [\n\t\t\t\t\t...config.redux.middlewares,\n\t\t\t\t\t...(plugin.config.redux.middlewares || []),\n\t\t\t\t]\n\n\t\t\t\tconfig.redux.combineReducers =\n\t\t\t\t\tconfig.redux.combineReducers || plugin.config.redux.combineReducers\n\n\t\t\t\tconfig.redux.createStore =\n\t\t\t\t\tconfig.redux.createStore || plugin.config.redux.createStore\n\t\t\t}\n\t\t}\n\n\t\tvalidatePlugin(plugin)\n\t})\n\n\treturn config as Config<TModels, TExtraModels>\n}\n\n/**\n * Shallow merges original object with the extra object, giving the precedence\n * to the original object.\n */\nfunction merge<T extends Record<string, any>>(\n\toriginal: T,\n\textra: T | undefined\n): T {\n\treturn extra ? { ...extra, ...original } : original\n}\n", "import createRematchStore from './rematchStore'\nimport { InitConfig, Models, RematchStore, ModelCreator } from './types'\nimport createConfig from './config'\n\n/**\n * Prepares a complete configuration and creates a Rematch store.\n */\nexport const init = <\n\tTModels extends Models<TModels> = Record<string, any>,\n\tTExtraModels extends Models<TModels> = Record<string, any>\n>(\n\tinitConfig?: InitConfig<TModels, TExtraModels>\n): RematchStore<TModels, TExtraModels> => {\n\tconst config = createConfig(initConfig || {})\n\treturn createRematchStore(config)\n}\n\nexport const createModel: ModelCreator = () => (mo): any => {\n\tconst { reducers = {}, effects = {} } = mo\n\n\treturn {\n\t\t...mo,\n\t\treducers,\n\t\teffects,\n\t}\n}\n\nexport default {\n\tinit,\n\tcreateModel,\n}\n\nexport * from './types'\n"],
  "mappings": ";;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAe,kCAAkC,OAAM;AACtD,MAAI;AACJ,MAAI,SAAS,MAAK;AAElB,MAAI,OAAO,WAAW,YAAY;AACjC,QAAI,OAAO,YAAY;AACtB,gBAAS,OAAO;AAAA,WACV;AACN,gBAAS,OAAO;AAChB,aAAO,aAAa;AAAA;AAAA,SAEf;AACN,cAAS;AAAA;AAGV,SAAO;AAAA;;;ACZR,IAAI;AAEJ,IAAI,OAAO,SAAS,aAAa;AAC/B,SAAO;AAAA,WACE,OAAO,WAAW,aAAa;AACxC,SAAO;AAAA,WACE,OAAO,WAAW,aAAa;AACxC,SAAO;AAAA,WACE,OAAO,WAAW,aAAa;AACxC,SAAO;AAAA,OACF;AACL,SAAO,SAAS;AAAA;AAGlB,IAAI,SAAS,yBAAS;AACtB,IAAO,aAAQ;;;AFVf,IAAI,eAAe,yBAAwB;AACzC,SAAO,KAAK,SAAS,SAAS,IAAI,UAAU,GAAG,MAAM,IAAI,KAAK;AAAA;AAGhE,IAAI,cAAc;AAAA,EAChB,MAAM,iBAAiB;AAAA,EACvB,SAAS,oBAAoB;AAAA,EAC7B,sBAAsB,gCAAgC;AACpD,WAAO,iCAAiC;AAAA;AAAA;AAQ5C,uBAAuB,KAAK;AAC1B,MAAI,OAAO,QAAQ,YAAY,QAAQ;AAAM,WAAO;AACpD,MAAI,QAAQ;AAEZ,SAAO,OAAO,eAAe,WAAW,MAAM;AAC5C,YAAQ,OAAO,eAAe;AAAA;AAGhC,SAAO,OAAO,eAAe,SAAS;AAAA;AA6BxC,qBAAqB,SAAS,gBAAgB,UAAU;AACtD,MAAI;AAEJ,MAAI,OAAO,mBAAmB,cAAc,OAAO,aAAa,cAAc,OAAO,aAAa,cAAc,OAAO,UAAU,OAAO,YAAY;AAClJ,UAAM,IAAI,MAAM;AAAA;AAGlB,MAAI,OAAO,mBAAmB,cAAc,OAAO,aAAa,aAAa;AAC3E,eAAW;AACX,qBAAiB;AAAA;AAGnB,MAAI,OAAO,aAAa,aAAa;AACnC,QAAI,OAAO,aAAa,YAAY;AAClC,YAAM,IAAI,MAAM;AAAA;AAGlB,WAAO,SAAS,aAAa,SAAS;AAAA;AAGxC,MAAI,OAAO,YAAY,YAAY;AACjC,UAAM,IAAI,MAAM;AAAA;AAGlB,MAAI,iBAAiB;AACrB,MAAI,eAAe;AACnB,MAAI,mBAAmB;AACvB,MAAI,gBAAgB;AACpB,MAAI,gBAAgB;AASpB,0CAAwC;AACtC,QAAI,kBAAkB,kBAAkB;AACtC,sBAAgB,iBAAiB;AAAA;AAAA;AAUrC,sBAAoB;AAClB,QAAI,eAAe;AACjB,YAAM,IAAI,MAAM;AAAA;AAGlB,WAAO;AAAA;AA2BT,qBAAmB,UAAU;AAC3B,QAAI,OAAO,aAAa,YAAY;AAClC,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI,eAAe;AACjB,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI,eAAe;AACnB;AACA,kBAAc,KAAK;AACnB,WAAO,uBAAuB;AAC5B,UAAI,CAAC,cAAc;AACjB;AAAA;AAGF,UAAI,eAAe;AACjB,cAAM,IAAI,MAAM;AAAA;AAGlB,qBAAe;AACf;AACA,UAAI,QAAQ,cAAc,QAAQ;AAClC,oBAAc,OAAO,OAAO;AAC5B,yBAAmB;AAAA;AAAA;AA8BvB,oBAAkB,QAAQ;AACxB,QAAI,CAAC,cAAc,SAAS;AAC1B,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI,OAAO,OAAO,SAAS,aAAa;AACtC,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI,eAAe;AACjB,YAAM,IAAI,MAAM;AAAA;AAGlB,QAAI;AACF,sBAAgB;AAChB,qBAAe,eAAe,cAAc;AAAA,cAC5C;AACA,sBAAgB;AAAA;AAGlB,QAAI,YAAY,mBAAmB;AAEnC,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,UAAI,WAAW,UAAU;AACzB;AAAA;AAGF,WAAO;AAAA;AAcT,0BAAwB,aAAa;AACnC,QAAI,OAAO,gBAAgB,YAAY;AACrC,YAAM,IAAI,MAAM;AAAA;AAGlB,qBAAiB;AAKjB,aAAS;AAAA,MACP,MAAM,YAAY;AAAA;AAAA;AAWtB,wBAAsB;AACpB,QAAI;AAEJ,QAAI,iBAAiB;AACrB,WAAO,OAAO;AAAA,MASZ,WAAW,oBAAmB,UAAU;AACtC,YAAI,OAAO,aAAa,YAAY,aAAa,MAAM;AACrD,gBAAM,IAAI,UAAU;AAAA;AAGtB,gCAAwB;AACtB,cAAI,SAAS,MAAM;AACjB,qBAAS,KAAK;AAAA;AAAA;AAIlB;AACA,YAAI,cAAc,eAAe;AACjC,eAAO;AAAA,UACL;AAAA;AAAA;AAAA,OAGH,KAAK,cAAgB,WAAY;AAClC,aAAO;AAAA,OACN;AAAA;AAML,WAAS;AAAA,IACP,MAAM,YAAY;AAAA;AAEpB,SAAO,QAAQ;AAAA,IACb;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,KACC,MAAM,cAAgB,YAAY;AAAA;AASvC,iBAAiB,SAAS;AAExB,MAAI,OAAO,YAAY,eAAe,OAAO,QAAQ,UAAU,YAAY;AACzE,YAAQ,MAAM;AAAA;AAKhB,MAAI;AAIF,UAAM,IAAI,MAAM;AAAA,WACT,GAAP;AAAA;AAAA;AAIJ,uCAAuC,KAAK,QAAQ;AAClD,MAAI,aAAa,UAAU,OAAO;AAClC,MAAI,oBAAoB,cAAc,aAAc,OAAO,cAAc,OAAQ;AACjF,SAAO,WAAW,oBAAoB,gBAAiB,MAAM;AAAA;AAG/D,+CAA+C,YAAY,UAAU,QAAQ,oBAAoB;AAC/F,MAAI,cAAc,OAAO,KAAK;AAC9B,MAAI,eAAe,UAAU,OAAO,SAAS,YAAY,OAAO,kDAAkD;AAElH,MAAI,YAAY,WAAW,GAAG;AAC5B,WAAO;AAAA;AAGT,MAAI,CAAC,cAAc,aAAa;AAC9B,WAAO,SAAS,eAAe,8BAA+B,GAAG,SAAS,KAAK,YAAY,MAAM,kBAAkB,KAAK,6DAA+D,aAAa,YAAY,KAAK,UAAU;AAAA;AAGjO,MAAI,iBAAiB,OAAO,KAAK,YAAY,OAAO,SAAU,KAAK;AACjE,WAAO,CAAC,SAAS,eAAe,QAAQ,CAAC,mBAAmB;AAAA;AAE9D,iBAAe,QAAQ,SAAU,KAAK;AACpC,uBAAmB,OAAO;AAAA;AAE5B,MAAI,UAAU,OAAO,SAAS,YAAY;AAAS;AAEnD,MAAI,eAAe,SAAS,GAAG;AAC7B,WAAO,gBAAiB,gBAAe,SAAS,IAAI,SAAS,SAAS,MAAO,OAAO,eAAe,KAAK,UAAU,gBAAiB,eAAe,QAAQ,6DAA8D,OAAO,YAAY,KAAK,UAAU;AAAA;AAAA;AAI9P,4BAA4B,UAAU;AACpC,SAAO,KAAK,UAAU,QAAQ,SAAU,KAAK;AAC3C,QAAI,UAAU,SAAS;AACvB,QAAI,eAAe,QAAQ,QAAW;AAAA,MACpC,MAAM,YAAY;AAAA;AAGpB,QAAI,OAAO,iBAAiB,aAAa;AACvC,YAAM,IAAI,MAAM,cAAe,MAAM;AAAA;AAGvC,QAAI,OAAO,QAAQ,QAAW;AAAA,MAC5B,MAAM,YAAY;AAAA,WACb,aAAa;AAClB,YAAM,IAAI,MAAM,cAAe,MAAM,0DAA4D,0BAAyB,YAAY,OAAO,qCAAuC;AAAA;AAAA;AAAA;AAsB1L,yBAAyB,UAAU;AACjC,MAAI,cAAc,OAAO,KAAK;AAC9B,MAAI,gBAAgB;AAEpB,WAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC3C,QAAI,MAAM,YAAY;AAEtB,QAAI,MAAuC;AACzC,UAAI,OAAO,SAAS,SAAS,aAAa;AACxC,gBAAQ,kCAAmC,MAAM;AAAA;AAAA;AAIrD,QAAI,OAAO,SAAS,SAAS,YAAY;AACvC,oBAAc,OAAO,SAAS;AAAA;AAAA;AAIlC,MAAI,mBAAmB,OAAO,KAAK;AAGnC,MAAI;AAEJ,MAAI,MAAuC;AACzC,yBAAqB;AAAA;AAGvB,MAAI;AAEJ,MAAI;AACF,uBAAmB;AAAA,WACZ,GAAP;AACA,0BAAsB;AAAA;AAGxB,SAAO,qBAAqB,OAAO,QAAQ;AACzC,QAAI,UAAU,QAAQ;AACpB,cAAQ;AAAA;AAGV,QAAI,qBAAqB;AACvB,YAAM;AAAA;AAGR,QAAI,MAAuC;AACzC,UAAI,iBAAiB,sCAAsC,OAAO,eAAe,QAAQ;AAEzF,UAAI,gBAAgB;AAClB,gBAAQ;AAAA;AAAA;AAIZ,QAAI,aAAa;AACjB,QAAI,YAAY;AAEhB,aAAS,KAAK,GAAG,KAAK,iBAAiB,QAAQ,MAAM;AACnD,UAAI,OAAO,iBAAiB;AAC5B,UAAI,UAAU,cAAc;AAC5B,UAAI,sBAAsB,MAAM;AAChC,UAAI,kBAAkB,QAAQ,qBAAqB;AAEnD,UAAI,OAAO,oBAAoB,aAAa;AAC1C,YAAI,eAAe,8BAA8B,MAAM;AACvD,cAAM,IAAI,MAAM;AAAA;AAGlB,gBAAU,QAAQ;AAClB,mBAAa,cAAc,oBAAoB;AAAA;AAGjD,iBAAa,cAAc,iBAAiB,WAAW,OAAO,KAAK,OAAO;AAC1E,WAAO,aAAa,YAAY;AAAA;AAAA;AAIpC,2BAA2B,eAAe,UAAU;AAClD,SAAO,WAAY;AACjB,WAAO,SAAS,cAAc,MAAM,MAAM;AAAA;AAAA;AA0B9C,4BAA4B,gBAAgB,UAAU;AACpD,MAAI,OAAO,mBAAmB,YAAY;AACxC,WAAO,kBAAkB,gBAAgB;AAAA;AAG3C,MAAI,OAAO,mBAAmB,YAAY,mBAAmB,MAAM;AACjE,UAAM,IAAI,MAAM,2EAA4E,oBAAmB,OAAO,SAAS,OAAO,kBAAkB;AAAA;AAG1J,MAAI,sBAAsB;AAE1B,WAAS,OAAO,gBAAgB;AAC9B,QAAI,gBAAgB,eAAe;AAEnC,QAAI,OAAO,kBAAkB,YAAY;AACvC,0BAAoB,OAAO,kBAAkB,eAAe;AAAA;AAAA;AAIhE,SAAO;AAAA;AAGT,yBAAyB,KAAK,KAAK,OAAO;AACxC,MAAI,OAAO,KAAK;AACd,WAAO,eAAe,KAAK,KAAK;AAAA,MAC9B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA;AAAA,SAEP;AACL,QAAI,OAAO;AAAA;AAGb,SAAO;AAAA;AAGT,iBAAiB,QAAQ,gBAAgB;AACvC,MAAI,OAAO,OAAO,KAAK;AAEvB,MAAI,OAAO,uBAAuB;AAChC,SAAK,KAAK,MAAM,MAAM,OAAO,sBAAsB;AAAA;AAGrD,MAAI;AAAgB,WAAO,KAAK,OAAO,SAAU,KAAK;AACpD,aAAO,OAAO,yBAAyB,QAAQ,KAAK;AAAA;AAEtD,SAAO;AAAA;AAGT,wBAAwB,QAAQ;AAC9B,WAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,QAAI,SAAS,UAAU,MAAM,OAAO,UAAU,KAAK;AAEnD,QAAI,IAAI,GAAG;AACT,cAAQ,QAAQ,MAAM,QAAQ,SAAU,KAAK;AAC3C,wBAAgB,QAAQ,KAAK,OAAO;AAAA;AAAA,eAE7B,OAAO,2BAA2B;AAC3C,aAAO,iBAAiB,QAAQ,OAAO,0BAA0B;AAAA,WAC5D;AACL,cAAQ,QAAQ,QAAQ,SAAU,KAAK;AACrC,eAAO,eAAe,QAAQ,KAAK,OAAO,yBAAyB,QAAQ;AAAA;AAAA;AAAA;AAKjF,SAAO;AAAA;AAaT,mBAAmB;AACjB,WAAS,OAAO,UAAU,QAAQ,QAAQ,IAAI,MAAM,OAAO,OAAO,GAAG,OAAO,MAAM,QAAQ;AACxF,UAAM,QAAQ,UAAU;AAAA;AAG1B,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,SAAU,KAAK;AACpB,aAAO;AAAA;AAAA;AAIX,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,MAAM;AAAA;AAGf,SAAO,MAAM,OAAO,SAAU,GAAG,GAAG;AAClC,WAAO,WAAY;AACjB,aAAO,EAAE,EAAE,MAAM,QAAQ;AAAA;AAAA;AAAA;AAsB/B,2BAA2B;AACzB,WAAS,OAAO,UAAU,QAAQ,cAAc,IAAI,MAAM,OAAO,OAAO,GAAG,OAAO,MAAM,QAAQ;AAC9F,gBAAY,QAAQ,UAAU;AAAA;AAGhC,SAAO,SAAU,cAAa;AAC5B,WAAO,WAAY;AACjB,UAAI,QAAQ,aAAY,MAAM,QAAQ;AAEtC,UAAI,YAAY,oBAAoB;AAClC,cAAM,IAAI,MAAM;AAAA;AAGlB,UAAI,gBAAgB;AAAA,QAClB,UAAU,MAAM;AAAA,QAChB,UAAU,oBAAoB;AAC5B,iBAAO,UAAU,MAAM,QAAQ;AAAA;AAAA;AAGnC,UAAI,QAAQ,YAAY,IAAI,SAAU,YAAY;AAChD,eAAO,WAAW;AAAA;AAEpB,kBAAY,QAAQ,MAAM,QAAQ,OAAO,MAAM;AAC/C,aAAO,eAAe,IAAI,OAAO;AAAA,QAC/B,UAAU;AAAA;AAAA;AAAA;AAAA;AAWlB,qBAAqB;AAAA;AAErB,IAAI,AAAyC,OAAO,UAAU,SAAS,YAAY,UAAU,SAAS,aAAa;AACjH,UAAQ;AAAA;;;;;;;;;;;;;;;;;0BG9nBR,KAAA;AACD,MAAI,OAAO,QAAQ,SAAC,OAAD;AAAA,WAAW,mBAAmB,KAAK;;AAEtD,MAAM,cAAc,kBAAoD;AAExE,MAAM,cAAc,gBAAA,MAAA,eAAyB,IAAI,YAAY;AAC7D,MAAM,YAAY,6BACjB,IAAI,YAAY,gBADC,MAAA,QAEb,IAAI,YAAY,UAFH,OAAA,CAEc;AAEhC,MAAM,gBAAc,IAAI,YAAY,eAAe;AACnD,MAAM,kBAAkB,IAAI,YAAY;AACxC,MAAM,eAAe,oBAAoB,SAAY,KAAK;AAE1D,SAAO,cACN,aACA,cACA;;4BAoBA,KAAwC,OAAA;AACzC,MAAM,gBAAuC;AAG7C,MAAM,mBAAmB,OAAO,KAAK,MAAM;AAC3C,mBAAiB,QAAQ,SAAC,YAAD;AACxB,QAAM,aAAa,oBAAoB,cACpC,aACG,MAAM,OAFO,MAEC;AAEpB,kBAAc,cAAc,MAAM,SAAS;;AAI5C,MAAM,kBAAkB,0BACvB,OACA,QAFuB;QACvB,UAAA,QAAA;AAAA,cAAgB,MAAM;;AAGtB,QAAI,OAAO,QAAQ,eAAe;AACjC,aAAO,cAAc,OAAO,MAAM,OAAO,OAAO,SAAS,OAAO;;AAGjE,WAAO;;AAGR,MAAM,mBAAmB,MAAM;AAG/B,MAAI,UAAU,CAAC,mBACZ,kBACA,SAAC,OAA6B,QAA9B;AAAA,QAAC,UAAD,QAAA;AAAC,cAAgB,MAAM;;AAAvB,WACA,gBAAgB,iBAAiB,OAAO,SAAS;;AAEpD,MAAI,cAAc,aAAa,SAAC,WAAD;AAC9B,cAAU,UAAU,SAAS,MAAM,MAAM,QAAQ;;AAGlD,MAAI,YAAY,SAAS,MAAM,QAAQ;;2BAatC,KAAA;MACO,eAAiB,IAAI,YAArB;AACR,MAAM,iBAAiB,cAA0B,IAAI;AACrD,MAAI,cAAc;AAElB,MAAI,gBAAgB,OAAO,KAAK,cAAc,QAAQ;AACrD,kBAAc,sBACb,OACA,QAFa;AAIb,UAAM,oBAAoB,aAAa,OAAO;AAE9C,UAAI,mBAAmB;AACtB,eAAO,eAAe,kBAAkB,OAAO,SAAS;;AAGzD,aAAO,eAAe,OAAO;;;AAI/B,MAAI,cAAc,iBAAiB,SAAC,eAAD;AAClC,kBAAc,cAAc,aAAa,QAAQ;;AAGlD,SAAO;;AASR,uBACC,aADD;AAGC,MAAM,oBAAkB,YAAY,mBAAmB;AAEvD,MAAI,CAAC,OAAO,KAAK,YAAY,UAAU,QAAQ;AAC9C,WAAO,SAAC,OAAD;AAAA,aAA4B;;;AAGpC,SAAO,kBAAgB,YAAY;;AAOpC,sCACC,gBADD;MACC,mBAAA,QAAA;AAAA,qBAAiC;;AAEjC,SAAO,CAAC,eAAe,YACtB,OAAO,WAAW,YAClB,OAAO,uCACL,OAAO,qCAAqC,kBAC5C;;AAOJ,6BAA6B,YAA7B;AACC,SAAO,WAAW,QAAQ,OAAO;;AC1J3B,IAAM,WAAW,mBAAI,KAAJ;AAAA,SACvB,OAAO,QAAQ,YAAY,QAAQ,QAAQ,CAAC,MAAM,QAAQ;;AAMpD,IAAM,sBAAsB,8BAAI,MAAJ;AAAA,SAClC,CAAC,QAAQ,OAAO,SAAS;;AAO1B,IAAM,WAAW,mBAAC,gBAAD;AAChB,MAAI,MAAuC;AAC1C,QAAM,cAAc;AACpB,QAAM,SAAmB;AAEzB,gBAAY,QAAQ,SAAC,YAAD;AACnB,UAAM,YAAY,WAAW;AAC7B,UAAM,eAAe,WAAW;AAChC,UAAI,WAAW;AACd,eAAO,KAAK;;;AAId,QAAI,OAAO,SAAS,GAAG;AACtB,YAAM,IAAI,MAAM,OAAO,KAAK;;;;AAKxB,IAAM,iBAAiB,yBAI7B,QAJ6B;AAM7B,WAAS,WAAA;AAAA,WAAM,CACd,CAAC,CAAC,MAAM,QAAQ,OAAO,UAAU,yCACjC,CAAC,CAAC,SAAS,OAAO,SAAS,yCAC3B,CACC,CAAC,SAAS,OAAO,MAAM,WACvB,iDAED,CACC,CAAC,MAAM,QAAQ,OAAO,MAAM,cAC5B,mDAED,CACC,CAAC,MAAM,QAAQ,OAAO,MAAM,YAC5B,8DAED,CACC,CAAC,oBAAoB,OAAO,MAAM,kBAClC,yDAED,CACC,CAAC,oBAAoB,OAAO,MAAM,cAClC;;;AAKI,IAAM,gBAAgB,wBAG5B,OAH4B;AAK5B,WAAS,WAAA;AAAA,WAAM,CACd,CAAC,CAAC,OAAO,6BACT,CAAC,OAAO,MAAM,SAAS,UAAU,sCACjC,CACC,MAAM,UAAU,UAAa,MAAM,gBAAgB,QACnD,8BAED,CACC,CAAC,oBAAoB,MAAM,cAC3B;;;AAKI,IAAM,iBAAiB,yBAI7B,QAJ6B;AAM7B,WAAS,WAAA;AAAA,WAAM,CACd,CACC,CAAC,oBAAoB,OAAO,iBAC5B,6CAED,CAAC,CAAC,oBAAoB,OAAO,UAAU,sCACvC,CACC,CAAC,oBAAoB,OAAO,YAC5B,wCAED,CACC,CAAC,oBAAoB,OAAO,gBAC5B,4CAED,CACC,CAAC,oBAAoB,OAAO,mBAC5B;;;AAKI,IAAM,uBAAuB,+BACnC,WACA,UACA,aAHmC;AAKnC,WAAS,WAAA;AAAA,WAAM,CACd,CACC,CAAC,CAAC,YAAY,MAAM,WADrB,2BAE0B,YAF1B,MAEuC,cAFvC,MAIA,CACC,OAAO,SAAS,iBAAiB,YADlC,sBAEqB,YAFrB,MAEkC,cAFlC;;;AAOK,IAAM,sBAAsB,8BAClC,WACA,SACA,YAHkC;AAKlC,WAAS,WAAA;AAAA,WAAM,CACd,CACC,CAAC,CAAC,WAAW,MAAM,OADpB,0BAEyB,YAFzB,MAEsC,aAFtC,MAIA,CACC,OAAO,QAAQ,gBAAgB,YADhC,qBAEoB,YAFpB,MAEiC,aAFjC;;;AC1IF,IAAM,yBAAyB,iCAG9B,SACA,WACA,YACA,UAN8B;AAQ9B,SAAO,OAAO,OACb,SAAC,SAAe,MAAhB;AACC,QAAM,SAAiB;MAAE,MAAS,YAAL,MAAkB;;AAE/C,QAAI,OAAO,YAAY,aAAa;AACnC,aAAO,UAAU;;AAGlB,QAAI,OAAO,SAAS,aAAa;AAChC,aAAO,OAAO;;AAGf,WAAO,QAAQ,SAAS;KAEzB;IACC;;;AAUH,IAAM,mBAAmB,2BAIxB,SACA,KACA,OANwB;AAQxB,MAAM,kBAAkB,QAAQ,SAAS,MAAM;AAG/C,MAAM,oBAAoB,OAAO,KAAK,MAAM;AAC5C,oBAAkB,QAAQ,SAAC,aAAD;AACzB,yBAAqB,MAAM,MAAM,MAAM,UAAU;AAEjD,oBAAgB,eAAe,uBAC9B,SACA,MAAM,MACN,aACA;;AAIF,MAAI,UAAiC;AAGrC,MAAI,MAAM,SAAS;AAClB,cACC,OAAO,MAAM,YAAY,aACrB,MAAM,QAAyC,QAAQ,YACxD,MAAM;;AAIX,MAAM,aAAa,OAAO,KAAK;AAC/B,aAAW,QAAQ,SAAC,YAAD;AAClB,wBAAoB,MAAM,MAAM,SAAS;AAEzC,QAAI,QAAW,MAAM,OAArB,MAA6B,cAAgB,QAAQ,YAAY,KAChE;AAGD,oBAAgB,cAAc,uBAC7B,SACA,MAAM,MACN,YACA;;;0BCxFD,QAAA;AACD,SAAO;IACN,QAAQ,kBAAkB,OAAO;IACjC,aAAa,OAAO;IACpB,eAHM,uBAGQ,QAAQ,IAHhB;AAIL,aAAO,QAAQ,QAAQ,SAAC,QAAD;AACtB,YAAI,OAAO,SAAS;AACnB,aAAG,OAAO;;;;IAIb,SAAS;;;AASX,2BAEE,QAFF;AAGC,SAAO,OAAO,KAAK,QAAQ,IAAI,SAAC,WAAD;AAC9B,QAAM,QAAQ,iBAAiB,WAAW,OAAO;AACjD,kBAAc;AACd,WAAO;;;AAQT,0BAEE,MAAc,OAFhB;AAGC,SAAA,SAAA;IACC;IACA,UAAU;KACP;;4BCzBH,QAAA;AAED,MAAM,MAAM,iBAAiB;AAG7B,MAAI,YAAY,YAAY,KAAK,wBAAwB;AAGzD,MAAI,cAAc,oBAAoB,SAAC,kBAAD;AACrC,QAAI,YAAY,YAAY,KAAK,iBAAiB;;AAGnD,MAAM,aAAa,iBAAiB;AAEpC,MAAI,eAAY,SAAA,IACZ,YADY;IAEf,MAAM,OAAO;IACb,UAHe,kBAGN,OAHM;AAId,oBAAc;AACd,yBAAmB,KAAK;AACxB,mBAAa,MAAM,KAAK;AACxB,WAAK,eAAe,kBAAkB;AACtC,iBAAW,SAAS;QAAE,MAAM;;;;AAI9B,aAAW,cAAc,OAAO;AAEhC,eAAa,SAAS,KAAK;AAG3B,MAAI,OAAO,QAAQ,SAAC,OAAD;AAAA,WAAW,aAAa,cAAc,KAAK;;AAE9D,MAAI,cAAc,kBAAkB,SAAC,gBAAD;AACnC,mBAAe,eAAe,cAAc,QAAQ;;AAGrD,SAAO;;AAGR,iCAEE,KAFF;AAGC,SAAO,SAAC,OAAD;AAAA,WAAW,SAAC,MAAD;AAAA,aAAU,SAAC,QAAD;AAC3B,YAAI,OAAO,QAAQ,IAAI,SAAS;AAE/B,eAAK;AAGL,iBAAO,IAAI,QAAQ,OAAO,MACzB,OAAO,SACP,MAAM,YACN,OAAO;;AAIT,eAAO,KAAK;;;;;AAId,sBAIC,cACA,KACA,OAND;AAQC,MAAM,kBAAkB;AAGxB,eAAa,SAAb,KACI,MAAM,QACN;AAEJ,mBAAiB,cAAc,KAAK;AAEpC,MAAI,cAAc,WAAW,SAAC,SAAD;AAC5B,YAAQ,OAAO;;;AAWjB,oBAIC,OACA,SALD;AAOC,UAAQ,QAAQ,SAAC,QAAD;AACf,QAAI,CAAC,OAAO;AAAS;AACrB,QAAM,aAAa,OAAO,KAAK,OAAO;AACtC,eAAW,QAAQ,SAAC,KAAD;AAClB,UAAI,CAAC,OAAO;AAAS;AACrB,UAAM,cAAc,OAAO,QAAQ;AAGnC,UAAM,oBAAoB,OAAO,gBAAgB;AAEjD,YAAM,OAAO,oBACV,WAAA;AAAA,iBAAA,OAAA,UAAA,QAAI,SAAJ,IAAA,MAAA,OAAA,OAAA,GAAA,OAAA,MAAA,QAAA;AAAI,iBAAJ,QAAA,UAAA;;AAAA,eACC,YAA+B,MAA/B,QAAA,CAAgC,OAAhC,OAA0C;UAC3C,OAAO,OAAO,OAAO,QAAQ;;;;ACnInC,IAAI,QAAQ;AAOZ,sBAIC,YAAA;;AAEA,MAAM,YAAS,oBAAG,WAAW,SAAd,OAAA,mBAAA,mBAAuC;AAEtD,WAAS;AAET,MAAM,SAAS;IACd,MAAM;IACN,QAAQ,WAAW,UAAU;IAC7B,SAAS,WAAW,WAAW;IAC/B,OAAK,SAAA;MACJ,UAAU;MACV,cAAc;MACd,WAAW;MACX,aAAa;OACV,WAAW,OALV;MAMJ,gBAAc,SAAA;QACb,MAAM;SADO,yBAAA,qBAET,WAAW,UAFF,OAAA,SAET,kBAAkB,mBAFT,OAAA,wBAE2B;;;AAK3C,iBAAe;AAGf,SAAO,QAAQ,QAAQ,SAAC,QAAD;AACtB,QAAI,OAAO,QAAQ;AAElB,aAAO,SAAS,MAAM,OAAO,QAAQ,OAAO,OAAO;AAGnD,UAAI,OAAO,OAAO,OAAO;AACxB,eAAO,MAAM,eAAe,MAC3B,OAAO,MAAM,cACb,OAAO,OAAO,MAAM;AAGrB,eAAO,MAAM,WAAW,MACvB,OAAO,MAAM,UACb,OAAO,OAAO,MAAM;AAGrB,eAAO,MAAM,eAAe,MAC3B,OAAO,MAAM,cACb,OAAO,OAAO,MAAM;AAGrB,eAAO,MAAM,YAAb,GAAA,OACI,OAAO,MAAM,WACZ,OAAO,OAAO,MAAM,aAAa;AAGtC,eAAO,MAAM,cAAb,GAAA,OACI,OAAO,MAAM,aACZ,OAAO,OAAO,MAAM,eAAe;AAGxC,eAAO,MAAM,kBACZ,OAAO,MAAM,mBAAmB,OAAO,OAAO,MAAM;AAErD,eAAO,MAAM,cACZ,OAAO,MAAM,eAAe,OAAO,OAAO,MAAM;;;AAInD,mBAAe;;AAGhB,SAAO;;AAOR,eACC,UACA,OAFD;AAIC,SAAO,QAAK,SAAA,IAAQ,OAAU,YAAa;;ICvF/B,OAAO,eAInB,YAJmB;AAMnB,MAAM,SAAS,aAAa,cAAc;AAC1C,SAAO,mBAAmB;;AAG3B,IAAa,cAA4B,wBAAA;AAAA,SAAM,SAAC,IAAD;uBACN,GAAhC,UAAA,WAAA,iBAAA,SAAW,KAAA,4BAAqB,GAAjB,SAAA,UAAA,gBAAA,SAAU,KAAA;AAEjC,WAAA,SAAA,IACI,IADJ;MAEC;MACA;;;;",
  "names": []
}
